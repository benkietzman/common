// vim: syntax=cpp
// vim600: fdm=marker
/* -*- c++ -*- */
///////////////////////////////////////////
// Utility
// -------------------------------------
// file       : Utility
// author     : Ben Kietzman
// begin      : 2013-11-30
// copyright  : kietzman.org
// email      : ben@kietzman.org
///////////////////////////////////////////

/**************************************************************************
*                                                                         *
*   This program is free software; you can redistribute it and/or modify  *
*   it under the terms of the GNU General Public License as published by  *
*   the Free Software Foundation; either version 2 of the License, or     *
*   (at your option) any later version.                                   *
*                                                                         *
**************************************************************************/

/*! \file Utility
* \brief Utility Class
*/
#ifndef _COMMON_UTILITY_
#define _COMMON_UTILITY_
// {{{ includes
#include <cerrno>
#include <csignal>
#include <cstring>
#include <ctime>
#include <fcntl.h>
#include <fstream>
#include <iostream>
#include <mutex>
#include <openssl/conf.h>
#include <openssl/err.h>
#include <openssl/ssl.h>
#include <poll.h>
#ifdef COMMON_SOLARIS
#include <procfs.h>
#endif
#include <string>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <zlib.h>
using namespace std;
#include "File"
#include "Json"
// }}}
extern "C++"
{
  namespace common
  {
    enum common_socket_type {COMMON_SOCKET_UNKNOWN, COMMON_SOCKET_ENCRYPTED, COMMON_SOCKET_UNENCRYPTED, COMMON_SOCKET_INVALID};
    // {{{ Utility
    //! Contains utility tools.
    /*!
    * Provides utility tools.
    */
    class Utility
    {
      private:
      bool m_bSslInit;
      mutex m_mutexConf;
      time_t m_ulModifyTime;
      File m_file;

      public:
      Json *m_conf;
      string m_strConf;

      Utility(string &strError);
      ~Utility();

      /*! \fn Json *conf()
      * \brief Interfaces with the configuration storage.
      * \return Returns a pointer to the configuration storage.
      */
      Json *conf();
      /*! \fn void daemonize()
      * \brief Turns the process into a system daemon.
      */
      void daemonize();
      /*! \fn string getConfPath()
      * \brief Gets the configuration storage path.
      * \return Returns the configuration storage path.
      */
      string getConfPath();
      /*! \fn bool getLine(FILE *pFile, string &strLine)
      * \brief Reads a line of data from a socket.
      * \param pFile Contains the file handle.
      * \param strLine Contains the newly read line.
      * \return Returns a boolean true/false value.
      */
      bool getLine(FILE *pFile, string &strLine);
      /*! \fn bool getLine(gzFile pgzFile, string &strLine)
      * \brief Reads a line of data from a zlib compressed file.
      * \param pgzFile Contains the file handle.
      * \param strLine Contains the newly read line.
      * \return Returns a boolean true/false value.
      */
      bool getLine(gzFile pgzFile, string &strLine);
      /*! \fn bool getLine(int fdFile, string &strLine, const time_t CTimeout, int &nReturn)
      * \brief Reads a line of data from a file/socket.
      * \param fdFile Contains the file descriptor.
      * \param strLine Contains the newly read line.
      * \param CTimeout Contains the timeout.
      * \param nReturn Contains the returned value from read.
      * \return Returns a boolean true/false value.
      */
      bool getLine(int fdFile, string &strLine, const time_t CTimeout, int &nReturn);
      /*! \fn bool getLine(int fdFile, string &strLine, int &nReturn)
      * \brief Reads a line of data from a file/socket.
      * \param fdFile Contains the file descriptor.
      * \param strLine Contains the newly read line.
      * \param nReturn Contains the returned value from read.
      * \return Returns a boolean true/false value.
      */
      bool getLine(int fdFile, string &strLine, int &nReturn);
      /*! \fn bool getLine(int fdFile, string &strLine)
      * \brief Reads a line of data from a file/socket.
      * \param fdFile Contains the file descriptor.
      * \param strLine Contains the newly read line.
      * \return Returns a boolean true/false value.
      */
      bool getLine(int fdFile, string &strLine);
      /*! \fn bool getLine(ifstream &inFile, string &strLine)
      * \brief Reads a line of data from a socket.
      * \param inFile Contains the file handle.
      * \param strLine Contains the newly read line.
      * \return Returns a boolean true/false value.
      */
      bool getLine(ifstream &inFile, string &strLine);
      /*! \fn bool getLine(istream &inStream, string &strLine)
      * \brief Reads a line of data from a stream.
      * \param inStream Contains the stream.
      * \param strLine Contains the newly read line.
      * \return Returns a boolean true/false value.
      */
      bool getLine(istream &inStream, string &strLine);
      /*! \fn bool getLine(SSL *ssl, string &strLine, const time_t CTimeout, int &nReturn)
      * \brief Reads a line of data from a socket.
      * \param ssl Contains the SSL handle.
      * \param strLine Contains the newly read line.
      * \param CTimeout Contains the timeout.
      * \param nReturn Contains the returned value from SSL_read.
      * \return Returns a boolean true/false value.
      */
      bool getLine(SSL *ssl, string &strLine, const time_t CTimeout, int &nReturn);
      /*! \fn bool getLine(SSL *ssl, string &strLine, int &nReturn)
      * \brief Reads a line of data from a socket.
      * \param ssl Contains the SSL handle.
      * \param strLine Contains the newly read line.
      * \param nReturn Contains the returned value from SSL_read.
      * \return Returns a boolean true/false value.
      */
      bool getLine(SSL *ssl, string &strLine, int &nReturn);
      /*! \fn bool getLine(SSL *ssl, string &strLine)
      * \brief Reads a line of data from a socket.
      * \param ssl Contains the SSL handle.
      * \param strLine Contains the newly read line.
      * \return Returns a boolean true/false value.
      */
      bool getLine(SSL *ssl, string &strLine);
      /*! \fn bool getLine(stringstream &ssData, string &strLine)
      * \brief Reads a line of data from a stream.
      * \param ssData Contains the string stream.
      * \param strLine Contains the newly read line.
      * \return Returns a boolean true/false value.
      */
      bool getLine(stringstream &ssData, string &strLine);
      /*! \fn bool isProcessAlreadyRunning(const string strProcess)
      * \brief Determines if another process of the same name is already running.
      * \param strProcess Contains process name.
      * \return Returns a boolean true/false value.
      */
      bool isProcessAlreadyRunning(const string strProcess);
      /*! \fn void msleep(const unsigned long ulMilliSec)
      * \brief Sleep given milliseconds.
      * \param ulMilliSec Contains the milliseconds.
      */
      void msleep(const unsigned long ulMilliSec);
      /*! \fn bool readConf(string &strError)
      * \brief Read configuration file.
      * \param strError Contains the error message.
      * \return Returns a boolean true/false value.
      */
      bool readConf(string &strError);
      /*! \fn void setConfPath(const string strPath)
      * \brief Sets the configuration storage path.
      * \param strError Contains the error message.
      */
      void setConfPath(const string strPath, string &strError);
      /*! \fn bool socketType(int fdSocket, common_socket_type &eType, string &strError)
      * \brief Take a peek of the current socket to determine if it's a regular or encrypted one.
      * \param fdSocket Contains the socket descriptor.
      * \param eType Returns an enum indicating if the socket is encrypted, unencrypted, or invalid.
      * \param strError Contains the error.
      * \return Returns a boolean true/false value.
      *   - SOC_UNENCRYPTED: This is a regular unencrypted socket.
      *   - SOC_ENCRYPTED:   This is an SSL encrypted socket;
      *   - SOC_INVALID:     Error occurred or the peer already closed the socket.
      */
      bool socketType(int fdSocket, common_socket_type &eType, string &strError);
      /*! \fn SSL_CTX *sslInit(const bool bSslServer, string &strError)
      * \brief OpenSSL initialization.
      * \param bSslServer A boolean indicates if the current program is an SSL server or client.  If true, the program is an SSL server; otherwise, it's an SSL client.
      * \param strError Returns an error message.
      * \return SSL_CTX contains the SSL context for establishing an SSL socket connection.
      */
      SSL_CTX *sslInit(const bool bSslServer, string &strError);
      /*! \fn SSL_CTX *sslInitClient(string &strError)
      * \brief OpenSSL initialization for a client.
      * \param strError Returns an error message.
      * \return SSL_CTX contains the SSL context for establishing an SSL socket connection.
      */
      SSL_CTX *sslInitClient(string &strError);
      /*! \fn SSL_CTX *sslInitServer(string &strError)
      * \brief OpenSSL initialization for a server.
      * \param strError Returns an error message.
      * \return SSL_CTX contains the SSL context for establishing an SSL socket connection.
      */
      SSL_CTX *sslInitServer(string &strError);
      /*! \fn bool sslLoadCertKey(SSL_CTX *ctx, const string strCertificate, const string strPrivateKey, string &strError)
      * \brief Loads the SSL certificate and private key into the SSL CTX and then checks their consistency.
      * \param ctx Contains the SSL context.
      * \param strCertificate Contains the certificate.
      * \param strPrivateKey Contains the private key.
      * \return Returns a boolean true/false value.
      */
      bool sslLoadCertKey(SSL_CTX *ctx, const string strCertificate, const string strPrivateKey, string &strError);
      /*! \fn int sslread(SSL *ssl, char *pszBuffer, int nSize, bool &bGood)
      * \brief Read data from SSL handle.
      * \param ssl SSL handle.
      * \param pszBuffer Data buffer.
      * \param int nSize Number of bytes.
      * \param bGood Boolean true/false value of whether the SSL handle is still good.
      * \return Number of bytes read.
      */
      int sslread(SSL *ssl, char *pszBuffer, int nSize, bool &bGood);
      /*! \fn string sslstrerror()
      * \brief Obtain an SSL error message.
      * \return Returns the error string.
      */
      string sslstrerror();
    };
    // }}}
  }
}
#endif
