// vim600: fdm=marker
///////////////////////////////////////////
// author     : Marco Escudero
// begin      : 2016-03-22
// email      : marco.escudero.eng@gmail.com
///////////////////////////////////////////

module.exports = 
{
  // {{{ ServiceJunction()
  ServiceJunction: function () 
  {
    var junction =
    {
      // {{{ variables
      m_conf: null,
      m_strConf: '/etc/central.conf',
      m_strApplication: null,
      m_strProgram: null,
      m_bUseSecureJunction: null,
      // }}}
      // {{{ getConf()
      getConf: function ()
      {
        return this.m_conf;
      },
      // }}}
      // {{{ mysqlUpdate()
      mysqlUpdate: function (strUser, strPassword, strServer, strDatabase, strUpdate)
      {
        // TODO under construction
        return null;
      },
      // }}}
      // {{{ mysqlQuery()
      mysqlQuery: function (strUser, strPassword, strServer, strDatabase, strQuery)
      {
        var mysql = require('mysql');
        var Q = require('q');
        var defer = Q.defer();
         
        var pool = mysql.createPool({
          host: strServer,
          user: strUser,
          password: strPassword,
          database: strDatabase,
          supportBigNumbers: true
        });
         
        pool.getConnection(function(err, connection)
        {
          if(err)
          {
            defer.resolve(err);
          }
          else
          {
            connection.query(strQuery, function(err, results)
            {
              connection.release();
              connection.destroy();
              if(err)
              {
                defer.resolve(err);
              }
              else
              {
                defer.resolve(results); 
              }
            });
          }
        });
         
        return defer.promise;
      },
      // }}}
      // {{{ nwp()
      nwp: function (strService, strFunction, nwpRequestHeader, nwpRequestData)
      {
        var bReady, bResult = false;
        var strError = null;
        var result = {};
         
        var request = {}; 
        var input = [];
        if (this.m_strApplication != null)
        {
          request['reqApp'] = this.m_strApplication;
        }
        if (this.m_strProgram != null)
        {
          request['reqProg'] = this.m_strProgram;
        }
        request['Service'] = 'nwp';
        request['nwpService'] = strService;
        request['nwpFunction'] = strFunction;
        input.push(JSON.stringify(request));
        request = null;
        request = {};
        request['NwpRequestHeader'] = nwpRequestHeader;
        request['NwpRequestData'] = nwpRequestData;
        input.push(JSON.stringify(request));
         
        var Q = require('q');
        var defer = Q.defer();
        this.request(input)
        .then(function (output)
        {
          var bFirst = true;
          var strNwpResponseHeader = null;
           
          // console.log(Array.isArray(output));
          for (var i = 0; i < output.length; i++)
          {
            if (bFirst)
            {
              bFirst = false;
              var response = JSON.parse(output[i]);
              if (response['Status'] !== undefined && response['Status'] == 'okay')
              {
                bResult = true;
              }
              if (response['Error'] !== undefined && response['Error'] != '')
              {
                strError = response['Error'];
              }
            }
            else
            {
              var response = JSON.parse(output[i]);
              if (response['NwpResponseHeader'] !== undefined)
              {
                result['nwpResponseHeader'] = response['NwpResponseHeader'];
              }
              if (response['NwpResultHeader'] !== undefined)
              {
                result['nwpResultHeader'] = response['NwpResultHeader'];
              }
              if (response['NwpResultArray'] !== undefined)
              {
                var nwpResultArray = response['NwpResultArray'];
                result['nwpResultArray'] = response['NwpResultArray'];
              }
            }
          }
          if (!bResult && strError == '')
          {
            // TODO error handling here
          }
           
          defer.resolve(result);
        });
        return defer.promise;
      },
      // }}}
      // {{{ readConf()
      readConf: function ()
      {
        if (!this.m_conf)
        {
          var fs = require('fs');
          this.m_conf = JSON.parse(fs.readFileSync(this.m_strConf, 'utf8'));
        }
      },
      // }}}
      // {{{ request()
      request: function (input)
      {
        var net = require('net');
        var Q = require('q');
        var defer = Q.defer();
        var sock = new net.Socket();
        var buffer = '';
        var output = [];
        this.readConf();
        var junctionServer = '';
        if(this.m_conf['Load Balancer'].indexOf(',') != -1)
        {
          junctionServer = this.m_conf['Service Junction'].split(',')[0];
        }
        else
        {
          junctionServer = this.m_conf['Load Balancer'];
        }
         
        sock.connect(5862, junctionServer, function ()
        {
          sock.setEncoding("utf8");
          for (var i = 0; i < input.length; i++)
          {
            sock.write(input[i] + "\n");
          }
          sock.write("end\n");
        });
        sock.on('data', function(data)
        {
          var bFoundEnd = false;
          var nPosition;
          buffer += data;
          while ((nPosition = buffer.indexOf("\n")) != -1)
          {
            var strLine = buffer.substr(0, nPosition);
            buffer = buffer.substr((nPosition + 1), (buffer.length - nPosition + 1));
            if (strLine == "end")
            {
              bFoundEnd = true;
            }
            else
            {
              output.push(strLine);
            }
          }
          if (bFoundEnd)
          {
            sock.destroy();
            defer.resolve(output);
          }
        });
        return defer.promise;
      },
      // }}}
      // {{{ setApplication()
      setApplication: function (strApplication)
      {
        this.m_strApplication = strApplication;
      },
      // }}}
      // {{{ setConf()
      setConf: function (strConf)
      {
        this.m_strConf = strConf;
      },
      // }}}
      // {{{ setProgram()
      setProgram: function (strProgram)
      {
        this.m_strProgram = strProgram;
      },
      // }}}
      // {{{ useSecureJunction()
      useSecureJunction: function (bUseSecureJunction)
      {
        if (typeof bUseSecureJunction === 'undefined')
        {
          bUseSecureJunction = true;
        }
        this.m_bUseSecureJunction = bUseSecureJunction;
      }
      // }}}
    };
    return junction;
  },
  // }}}
};
